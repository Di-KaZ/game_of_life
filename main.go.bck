// package main
// import (
// 	"fmt"
// 	// "math/rand"
// 	"time"
//
// 	tea "github.com/charmbracelet/bubbletea"
// 	"github.com/charmbracelet/lipgloss"
//
// 	"os"
// )
//
// type errMsg error
//
// type cell struct {
// 	alive      bool
// 	alive_turn int
// }
//
// type cursor_pos struct {
// 	x int
// 	y int
// }
//
// type model struct {
// 	width      int
// 	height     int
// 	quitting   bool
// 	err        error
// 	fps        time.Duration
// 	frame      *int
// 	next_cells []cell
// 	cells      []cell
// 	cursor_pos *cursor_pos
// 	pause      *bool
// }
//
// type Tick struct{}
//
// func initialModel() model {
// 	var width = 60
// 	var height = 40
//
// 	var model = model{
// 		width:      width,
// 		height:     height,
// 		frame:      new(int),
// 		fps:        12,
// 		cells:      make([]cell, width*height),
// 		next_cells: make([]cell, width*height),
// 	}
// 	*model.frame = 0
// 	model.cursor_pos = new(cursor_pos)
// 	model.pause = new(bool)
// 	*model.pause = false
// 	model.cursor_pos.x = 0
// 	model.cursor_pos.y = 0
// 	for i := 0; i < height*width; i++ {
// 		model.cells[i] = cell{alive: false, alive_turn: 1}
// 		model.next_cells[i] = cell{alive: false, alive_turn: 1}
// 	}
// 	return model
// }
//
// func (m model) isValidCoordinateAndAlive(x int, y int) bool {
// 	return x > 0 &&
// 		x < m.width &&
// 		y > 0 &&
// 		y < m.height &&
// 		m.cells[y*m.width+x].alive
// }
//
// func (m model) countNeighbors(y int, x int) int {
// 	var neighbors = 0
//
// 	for i := -1; i <= 1; i++ {
// 		for j := -1; j <= 1; j++ {
// 			if i == 0 && j == 0 {
// 				continue
// 			}
//
// 			if m.isValidCoordinateAndAlive(x+j, y+i) {
// 				neighbors++
// 			}
// 		}
// 	}
//
// 	return neighbors
// }
//
// func (m model) _23Alive(pos int) {
// 	var y = pos / m.width
// 	var x = pos % m.width
// 	var neighbors = m.countNeighbors(y, x)
// 	if neighbors == 3 && !m.cells[pos].alive {
// 		m.next_cells[pos].alive = true
// 	} else if (neighbors == 3 || neighbors == 2) && m.cells[pos].alive {
// 		m.next_cells[pos].alive = true
// 	} else {
// 		m.next_cells[pos].alive = false
// 	}
// 	if m.cells[pos].alive && m.next_cells[pos].alive {
// 		m.cells[pos].alive_turn++
// 	} else {
// 		m.cells[pos].alive_turn = 1
// 	}
// }
//
// func (m model) Tick() tea.Cmd {
// 	return tea.Tick(time.Second/6, func(t time.Time) tea.Msg {
// 		for pos := 0; pos < m.width*m.height; pos++ {
// 			m._23Alive(pos)
// 		}
// 		for i := 0; i < m.height*m.width; i++ {
// 			m.cells[i].alive = m.next_cells[i].alive
// 			m.next_cells[i].alive = false
// 		}
// 		*m.frame++
// 		return Tick{}
// 	})
// }
//
// func (m model) Init() tea.Cmd {
// 	return m.Tick()
// }
//
// func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
// 	switch msg := msg.(type) {
// 	case Tick:
// 		if !*m.pause {
// 			return m, m.Tick()
// 		}
// 	case tea.KeyMsg:
// 		switch msg.String() {
// 		case "q", "esc", "ctrl+c":
// 			m.quitting = true
// 			return m, tea.Quit
// 		case " ":
// 			*m.pause = !*m.pause
// 			if !*m.pause {
// 				return m, m.Tick()
// 			} else {
// 				return m, nil
// 			}
// 		case "ctrl+l":
// 			return m, m.Tick()
// 		case "h":
// 			if m.cursor_pos.x-1 > 0 {
// 				m.cursor_pos.x--
// 			}
// 		case "l":
// 			if m.cursor_pos.x+1 < m.width {
// 				m.cursor_pos.x++
// 			}
// 		case "k":
// 			if m.cursor_pos.y-1 >= 0 {
// 				m.cursor_pos.y--
// 			}
// 		case "j":
// 			if m.cursor_pos.y+1 >= 0 {
// 				m.cursor_pos.y++
// 			}
// 		case "t":
// 			m.cells[m.cursor_pos.y*m.width+m.cursor_pos.x].alive = !m.cells[m.cursor_pos.y*m.width+m.cursor_pos.y].alive
// 		default:
// 			return m, nil
// 		}
// 	case errMsg:
// 		m.err = msg
// 		return m, nil
// 	default:
// 		var cmd tea.Cmd
// 		return m, cmd
// 	}
// 	return m, nil
// }
//
// var alive_cell_style = lipgloss.NewStyle().Background(lipgloss.Color("10"))
//
// var colors = [...]lipgloss.Color{
// 	lipgloss.Color("5"),
// 	lipgloss.Color("6"),
// 	lipgloss.Color("7"),
// }
//
// func (c cell) View(hovered bool) string {
// 	content := " "
// 	if hovered {
// 		content = "X"
// 	}
// 	if c.alive {
// 		/// change color based on how many turns have been played
// 		// if more than available colors take the last one
// 		if c.alive_turn >= len(colors) {
// 			c.alive_turn = len(colors) - 1
// 		}
// 		return alive_cell_style.Foreground(colors[c.alive_turn]).Render(content)
// 	} else {
// 		return content
// 	}
// }
//
// var title_theme = lipgloss.NewStyle().
// 	Bold(true).
// 	Foreground(lipgloss.Color("5")).
// 	Align(lipgloss.Center)
//
// var stats_theme = lipgloss.NewStyle().
// 	Align(lipgloss.Center)
//
// var border_theme = lipgloss.NewStyle().
// 	Margin(0, 1, 0, 0).
// 	Border(lipgloss.NormalBorder())
//
// func (m model) RenderBoard() string {
// 	board := ""
// 	for i := 0; i < m.width*m.height; i++ {
// 		y := i / m.width
// 		x := i % m.width
// 		hovered := m.cursor_pos.y == y && m.cursor_pos.x == x && *m.pause
// 		board += m.cells[i].View(hovered)
// 		if x == m.width-1 && y < m.height-1 {
// 			board += "\n"
// 		}
// 	}
// 	return border_theme.Render(board)
// }
//
// func (m model) View() string {
//
// 	if m.err != nil {
// 		return m.err.Error()
// 	}
//
// 	title := title_theme.Render("Game Of Life\n\n")
// 	frame := stats_theme.Render(fmt.Sprintf("Generation: %d", *m.frame))
// 	fps := stats_theme.Render(fmt.Sprintf("FPS: %d\n", int(m.fps)))
// 	board := m.RenderBoard()
//
// 	stats := border_theme.Copy().
// 		Padding(1).
// 		Width(20).
// 		Render(lipgloss.JoinVertical(
// 			lipgloss.Top,
// 			title,
// 			fps,
// 			frame,
// 		))
//
// 	return lipgloss.JoinHorizontal(
// 		lipgloss.Top,
// 		board,
// 		stats,
// 	)
// }
//
// var file *os.File
//
// func main() {
// 	f, err := tea.LogToFile("debug.log", "debug")
// 	file = f
// 	if err != nil {
// 		fmt.Println("fatal:", err)
// 		os.Exit(1)
// 	}
// 	p := tea.NewProgram(initialModel())
// 	if _, err := p.Run(); err != nil {
// 		fmt.Println(err)
// 		os.Exit(1)
// 	}
// 	defer f.Close()
// }
